<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GGP FASHION - Pure Showroom</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* 스크롤바 숨김 및 스크롤 영역 제거 (가상 스크롤 사용) */
        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden; /* 네이티브 스크롤 차단 */
            background-color: black;
        }

        /* 비디오 컨테이너 */
        #video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 재생 버튼 펄스 효과 */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
            100% { transform: scale(0.8); box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }
        .play-btn-pulse {
            animation: pulse-ring 2s infinite;
        }
    </style>
</head>
<body class="bg-black">

    <!-- Fixed Video Background -->
    <div id="video-container">
        <video 
            id="main-video"
            muted 
            loop
            playsinline 
            preload="auto"
            class="w-full h-full object-cover"
        >
            <source src="https://lhgjkbngqmysxnhqwcoc.supabase.co/storage/v1/object/public/ggp_fashion/ggp_fashion_02.webm" type="video/webm">
        </video>
    </div>

    <!-- UI Overlay: 재생 상태일 때는 숨겨져 있다가, 수동 조작 시 나타남 -->
    <div id="control-indicator" class="fixed bottom-12 left-1/2 transform -translate-x-1/2 z-50 flex flex-col items-center justify-center text-white transition-all duration-500 opacity-0 translate-y-4 pointer-events-none mix-blend-difference">
        
        <div class="flex items-center gap-8">
            <!-- Left Arrow -->
            <div class="flex flex-col items-center gap-1 opacity-70">
                <i data-lucide="move-left" class="w-6 h-6 animate-pulse"></i>
            </div>
            
            <!-- Center Play Button (Pointer events enabled) -->
            <button id="resume-btn" class="group pointer-events-auto flex flex-col items-center gap-2 transition-transform hover:scale-110 active:scale-95 focus:outline-none">
                <div class="relative w-14 h-14 border-2 border-white rounded-full flex items-center justify-center bg-black/20 backdrop-blur-sm group-hover:bg-white/20 transition-colors play-btn-pulse">
                    <!-- Play Icon -->
                    <i data-lucide="play" class="w-6 h-6 fill-white ml-1"></i>
                </div>
                <span class="text-[10px] tracking-[0.3em] uppercase font-bold text-white shadow-black drop-shadow-md">Resume</span>
            </button>

            <!-- Right Arrow -->
            <div class="flex flex-col items-center gap-1 opacity-70">
                <i data-lucide="move-right" class="w-6 h-6 animate-pulse"></i>
            </div>
        </div>

        <!-- Guide Text -->
        <p class="mt-4 text-[10px] text-white/60 tracking-widest font-light uppercase">Scroll to Rotate / Click to Play</p>
    </div>

    <script>
        lucide.createIcons();

        const video = document.getElementById('main-video');
        const indicator = document.getElementById('control-indicator');
        const resumeBtn = document.getElementById('resume-btn');
        
        // --- 상태 변수 ---
        let isAutoPlaying = true;
        let targetTime = 0;
        
        const SCROLL_SENSITIVITY = 0.002; 
        const TOUCH_SENSITIVITY = 0.005;

        // 1. 초기 로드 및 자동 재생 시작
        video.addEventListener('loadedmetadata', () => {
            video.play().catch(e => console.log("Autoplay failed:", e));
        });

        // 2. [기능] 자동 재생 중단 (수동 모드 진입)
        function stopAutoPlay() {
            if (isAutoPlaying) {
                isAutoPlaying = false;
                video.pause();
                targetTime = video.currentTime;
                
                // UI 표시 (투명도 1, 위치 원래대로)
                indicator.classList.remove('opacity-0', 'translate-y-4');
            }
        }

        // 3. [기능] 자동 재생 재개 (영상 모드 복귀)
        function resumeAutoPlay(e) {
            // 이벤트 버블링 방지 (화면 클릭으로 인한 stopAutoPlay 호출 방지)
            if(e) e.stopPropagation();

            if (!isAutoPlaying) {
                isAutoPlaying = true;
                video.play();
                
                // UI 숨김
                indicator.classList.add('opacity-0', 'translate-y-4');
            }
        }

        // 재생 버튼 클릭 이벤트 연결
        resumeBtn.addEventListener('click', resumeAutoPlay);
        // 터치 환경 대응
        resumeBtn.addEventListener('touchstart', (e) => {
            // 터치 시 scroll 이벤트나 touchmove로 전파되어 멈추는 것 방지
            e.stopPropagation(); 
            resumeAutoPlay(e);
        }, {passive: false});


        // 4. 사용자 인터랙션 감지 (화면 클릭/터치 시 멈춤)
        window.addEventListener('mousedown', (e) => {
            // 재생 버튼이 아닌 곳을 눌렀을 때만 멈춤
            if (!resumeBtn.contains(e.target)) {
                stopAutoPlay();
            }
        });
        
        window.addEventListener('touchstart', (e) => {
            if (!resumeBtn.contains(e.target)) {
                stopAutoPlay();
                touchStartY = e.touches[0].clientY;
            }
        });

        // 5. Infinite Scroll Logic
        window.addEventListener('wheel', (e) => {
            stopAutoPlay();
            if (!video.duration) return;
            targetTime += e.deltaY * SCROLL_SENSITIVITY;
            handleLooping();
        });

        let touchStartY = 0;
        window.addEventListener('touchmove', (e) => {
            // 버튼 위에서의 터치 무브는 무시하려면 조건 추가 가능하나, 
            // 보통 스크롤 의도이므로 멈추는 게 자연스러움
            stopAutoPlay();
            if (!video.duration) return;

            const touchCurrentY = e.touches[0].clientY;
            const deltaY = touchStartY - touchCurrentY;
            touchStartY = touchCurrentY;

            targetTime += deltaY * TOUCH_SENSITIVITY;
            handleLooping();
        });

        function handleLooping() {
            const duration = video.duration;
            if (targetTime < 0) {
                targetTime = duration + (targetTime % duration);
            } else if (targetTime > duration) {
                targetTime = targetTime % duration;
            }
        }

        // 6. 렌더링 루프
        function renderLoop() {
            if (!isAutoPlaying && video.duration) {
                if (!video.seeking) {
                    if (Math.abs(video.currentTime - targetTime) > 0.0001) {
                        video.currentTime = targetTime;
                    }
                }
            }
            requestAnimationFrame(renderLoop);
        }

        requestAnimationFrame(renderLoop);

    </script>
</body>
</html>
